
import com.typesafe.sbt.SbtNativePackager.NativePackagerKeys._
import com.typesafe.sbt.SbtNativePackager.{packageArchetype, _}
import de.johoop.ant4sbt.Ant4Sbt._
import sbt.Keys._
import sbt._
import sbtassembly.Plugin.AssemblyKeys._
import sbtassembly.Plugin._
import sbtrelease.ReleasePlugin.ReleaseKeys._
import sbtrelease.ReleasePlugin._
import sbtrelease.ReleaseStateTransformations._
import sbtrelease.{ReleaseStep, _}

// For Sonatype publishing
//import com.jsuereth.pgp.sbtplugin.PgpKeys._
object PnlsBuild extends Build {
  val appName = "pnl"
  //val appVersion = "0.1"
  //  val buildNumber = Option(System.getenv("BUILD_NUMBER")).map("."+_).getOrElse("-SNAPSHOT")
  val sparkVersion = Option(System.getenv("SPARK_VERSION")).getOrElse("1.2.0")
  val sprayVersion = "1.3.1"
  val hadoopVersion = "2.4.1"
  val scalaCompilerVersion = Option(System.getenv("SCALA_VERSION")).getOrElse("2.10.4")

  val sparkScope = if (System.getenv("EXCLUDE_SPARK") != null) {
    "provided"
  } else {
    "compile"
  }
  private val noPubEnv: String = System.getenv("NO_PUBLISH_ON_RELEASE")
  val noPublishOnRelease = noPubEnv != null && noPubEnv == "true"
  val excludeHadoopCore = ExclusionRule(organization = "org.apache.hadoop")
  //lazy val generator = sbt.Project("slick-generator", file("generator"), settings = generatorSettings)

  def generatorSettings = Defaults.defaultSettings ++ Seq(
    //     libraryDependencies += "com.oracle.oracle" % "ojdbc6" % "11.2.0.2.0" ,
    resolvers += "Typesafe Releases" at "http://repo.typesafe.com/typesafe/maven-releases/",
    libraryDependencies += "com.typesafe.slick" %% "slick-extensions" % "2.1.0"
  )

  lazy val root = sbt.Project(appName, file("."), settings = rootSettings).aggregate(pnlAssembly, data, ui, spray/*,generator*/)
  lazy val data = sbt.Project(appName + "-data", file("data"), settings = pnlsSettings)//.dependsOn(generator)
  lazy val ui = sbt.Project(appName + "-ui", file("ui"), settings = uiSettings)
    .settings(net.virtualvoid.sbt.graph.Plugin.graphSettings: _*)
  lazy val spray = sbt.Project(appName + "-spray", file("spray"), settings = spraySettings)
    .dependsOn(data % "compile->compile;test->test").dependsOn(ui).settings(net.virtualvoid.sbt.graph.Plugin.graphSettings: _*)
  lazy val pnlAssembly = sbt.Project(appName + "-dist", file("assembly"), settings = pnlAssemblySettings).dependsOn(spray)
  val releaseSteps = List[ReleaseStep](
    checkSnapshotDependencies,
    inquireVersions,
    runClean,
    runTest,
    setReleaseVersion,
    commitReleaseVersion,
    tagRelease,
    releaseTask(packageZipTarball in Universal)) ++
    (if (noPublishOnRelease) {
      Seq.empty[ReleaseStep]
    } else {
      List[ReleaseStep](publishArtifacts)
    }) ++
    Seq[ReleaseStep](
      setNextVersion,
      commitNextVersion,
      pushChanges
    )

  def sharedSettings: Seq[Def.Setting[_]] = Defaults.defaultSettings ++ assemblySettings ++ releaseSettings ++
    Seq(
    organization := "com.db.gm.marketrisk.starc",
    // version := appVersion,
         scalaVersion :=  scalaCompilerVersion,
         //scalaVersion := "2.10.4",
    resolvers += Resolver.mavenLocal,
    resolvers += "Typqesafe Releases" at "http://repo.typesafe.com/typesafe/maven-releases/",
    resolvers += "spray repo" at "http://repo.spray.io",
	resolvers += "Artifactory" at "https://artifactory.intranet.db.com/artifactory/mvn-libs-release/",
    resolvers += "starc repo" at "http://lonpldpuappu4.uk.db.com:8443/nexus/content/groups/starc/",
    libraryDependencies += "org.scalatest" %% "scalatest" % "2.1.5" % "test",
    //publishTo := Some(Resolver.file("file",  new File( "/tmp/junk" )) ),

    publishTo <<= version { (v: String) =>
			  val nexus = "https://artifactory.intranet.db.com/artifactory/"
			  val repo = if (v.trim.endsWith("SNAPSHOT"))
				Some("snapshots" at nexus + "mvn-snapshot-local")
			  else
				Some("releases"  at nexus + "mvn-public-local")
			  println(s"Publishing to $repo")
			  repo
			},
    //publishTo := Some("GM Nexus" at "http://gmrepo.gslb.db.com:8481/nexus-webapp/content/repositories/socratesreleases/"),
    credentials += Credentials("Artifactory Realm",
                                     "artifactory.intranet.db.com",
                                     Option(System.getenv("RFDS_ARTIFACTORY_USER")).getOrElse(""),
                                     Option(System.getenv("RFDS_ARTIFACTORY_USER_PWD")).getOrElse("")),
    credentials += Credentials("Sonatype Nexus Repository Manager",
      "lonpldpuappu4.uk.db.com",
      Option(System.getenv("NEXUS_USER")).getOrElse(""),
      Option(System.getenv("NEXUS_PASSWORD")).getOrElse("")),
    /*  libraryDependencies += "com.typesafe" %% "scalalogging-slf4j" % "1.0.1",*/
    javaOptions += "-XX:MaxPermSize=2g",
    fork := true,
    releaseProcess := releaseSteps,
      scalacOptions += "-target:jvm-1.7"
  ) ++ net.virtualvoid.sbt.graph.Plugin.graphSettings ++ extraAssemblySettings

  def rootSettings: Seq[Def.Setting[_]] = sharedSettings ++ Seq(
  )

  val packageZip = taskKey[File]("package-zip")

  def pnlAssemblySettings: Seq[Def.Setting[_]] = sharedSettings ++ packageArchetype.java_server ++ Seq(
    jarName in assembly := "assembly-project.jar",
    mappings in Universal := {
      // universalMappings: Seq[(File,String)]
      val universalMappings = (mappings in Universal).value
      val fatJar = (assembly in Compile).value
      // removing means filtering
      val filtered: Seq[(File, String)] = universalMappings filter {
        case (file, name) => !name.endsWith(".jar")
      }
      // add the fat jar
      filtered :+ (fatJar -> ("lib/" + fatJar.getName))
    },
    packageZip := (baseDirectory in Compile).value / "target" / "universal" / (name.value + "-" + version.value + ".zip"),
    artifact in(Universal, packageZip) ~= { (art: Artifact) => art.copy(`type` = "zip", extension = "zip")},
    scriptClasspath := Seq((jarName in assembly).value),
    publish <<= publish dependsOn (packageBin in Universal),
    publishM2 <<= publishM2 dependsOn (packageBin in Universal),
    publishLocal <<= (publishLocal) dependsOn (packageBin in Universal)
  ) ++ addArtifact(artifact in(Universal, packageZip), packageZip in Universal)

  def consoleSetings = sharedSettings ++ Seq(
    //libraryDependencies += "org.apache.spark" %% "spark-repl" % sparkVersion % sparkScope,
    libraryDependencies += "org.apache.spark" %% "spark-hive" % sparkVersion % sparkScope,
    retrieveManaged := true,
    excludeFilter in unmanagedResources := ""
  )

  def uiSettings = sharedSettings ++ antSettings ++ addAntTasks("build", "clean") ++ Seq(
    unmanagedResourceDirectories in Compile += baseDirectory.value / "src/main/extjs",
    excludeFilter in unmanagedResources := "",
    libraryDependencies += "io.spray" %% "spray-routing" % sprayVersion % "test",
    libraryDependencies += "io.spray" %% "spray-can" % sprayVersion % "test",
    libraryDependencies += "io.spray" %% "spray-json" % "1.2.6" % "test",
    libraryDependencies += "org.apache.spark" %% "spark-hive" % sparkVersion % "test" excludeAll (excludeHadoopCore),
    libraryDependencies += "org.apache.hadoop" % "hadoop-client" % hadoopVersion % "test",
    antBuildFile := baseDirectory.value / "src/main/extjs/VarByRisk/build.xml",
    antBaseDir := baseDirectory.value / "src/main/extjs/VarByRisk/"
  ) ++ (if (System.getenv("BUID_EXTJS") != null) {
    Seq((copyResources in Compile) <<= (copyResources in Compile) dependsOn antTaskKey("build"),
      clean <<= clean dependsOn antTaskKey("clean"))
  } else {
    Seq.empty
  })

  def spraySettings = sharedSettings ++ Seq(
    libraryDependencies += "com.db.gdauth.tomcat" % "tomcat70" % "1.0.1",
    //libraryDependencies += "org.apache.spark" %% "spark-repl" % sparkVersion,
    libraryDependencies += "io.spray" %% "spray-routing" % sprayVersion,
    libraryDependencies += "io.spray" %% "spray-can" % sprayVersion,
    libraryDependencies += "io.spray" %% "spray-json" % "1.2.6",
    libraryDependencies += "org.apache.spark" %% "spark-streaming" % sparkVersion % sparkScope,
    libraryDependencies += "org.apache.spark" %% "spark-hive" % sparkVersion % sparkScope,
    /*  libraryDependencies += "io.spray" % "sptray-testkit" % sprayVersion % "test",*/
    //libraryDependencies += "org.specs2" %% "specs2" % "2.4.4" % "test",
    excludeFilter in unmanagedResources := ""
  )

  val pnlsSettings = sharedSettings ++ Seq(
    name := appName + "-data",
    libraryDependencies += "org.apache.spark" %% "spark-streaming" % sparkVersion % sparkScope excludeAll (excludeHadoopCore),
    libraryDependencies += "org.apache.spark" %% "spark-hive" % sparkVersion % sparkScope excludeAll (excludeHadoopCore),
    libraryDependencies += "org.apache.hadoop" % "hadoop-client" % hadoopVersion % sparkScope,
    libraryDependencies += "com.oracle.oracle" % "ojdbc6" % "11.2.0.2.0",
    libraryDependencies += "com.typesafe.play" %% "anorm" % "2.3.1",
    //    libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.0.0" % "runtime",
    libraryDependencies += "com.github.nscala-time" %% "nscala-time" % "1.2.0",
    libraryDependencies += "io.spray" %% "spray-caching" % sprayVersion,
    libraryDependencies += "com.chuusai" %% "shapeless" % "1.2.4", //should match version spray depends on

    libraryDependencies += "org.scalanlp" %% "breeze" % "0.10",
 //   libraryDependencies += "com.google.guava" %% "guava" % "14.0.1"  % "test",
    // resolvers += "Akka Repository" at "http://repo.akka.io/releases/",
    //libraryDependencies += "org.apache.hadoop" % "hadoop-client" % "2.1.0-beta",
    libraryDependencies += "junit" % "junit" % "4.11",
    //   libraryDependencies += "org.scalatest" %% "scalatest" % "1.9.1",
	  libraryDependencies += "org.jasypt" % "jasypt" % "1.9.2",
	  libraryDependencies += "com.typesafe.slick" %% "slick-extensions" % "2.0.2"
  )

  /* val webSettings = sharedSettings  ++  Seq(
     name := appName + "-web"
   )
 */
  /*
    case PathList("org", "datanucleus", xs @ _*)             => MergeStrategy.discard
      case m if m.toLowerCase.endsWith("manifest.mf")          => MergeStrategy.discard
      case m if m.toLowerCase.matches("meta-inf.*\\.sf$")      => MergeStrategy.discard
      case "log4j.properties"                                  => MergeStrategy.discard
      case m if m.toLowerCase.startsWith("meta-inf/services/") => MergeStrategy.filterDistinctLines
      case "reference.conf"                                    => MergeStrategy.concat
      case _                                                   => MergeStrategy.first
   */
  def extraAssemblySettings() = Seq(
    test in assembly := {},
    mergeStrategy in assembly := {
      case PathList("org", "datanucleus", xs@_*) => MergeStrategy.discard
      case m if m.toLowerCase.endsWith("manifest.mf") => MergeStrategy.discard
      case m if m.toLowerCase.matches("meta-inf.*\\.sf$") => MergeStrategy.discard
      case "log4j.properties" => MergeStrategy.discard
      case m if m.toLowerCase.startsWith("meta-inf/services/") => MergeStrategy.filterDistinctLines
      case "reference.conf" => MergeStrategy.concat
      case _ => MergeStrategy.first
    }
  )
}
