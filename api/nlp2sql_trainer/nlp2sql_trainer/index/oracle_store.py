from __future__ import annotations
from typing import List, Dict, Any, Tuple
import json
import numpy as np
import oracledb

def _major_version(conn) -> int:
    try:
        ver = conn.version  # e.g. '23.4.0.24.05'
        return int(str(ver).split('.')[0])
    except Exception:
        return 12

def _has_db_type_vector() -> bool:
    return hasattr(oracledb, "DB_TYPE_VECTOR")

def create_table(conn, table: str, dim: int, prefer_native: bool = True) -> Dict[str, Any]:
    cur = conn.cursor()
    major = _major_version(conn)
    native_ok = prefer_native and major >= 23 and _has_db_type_vector()
    # Drop if exists
    try:
        cur.execute(f"DROP TABLE {table} PURGE")
    except Exception:
        try:
            cur.execute(f"DROP TABLE {table}")
        except Exception:
            pass

    if native_ok:
        ddl = f"""
        CREATE TABLE {table} (
          id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          text CLOB,
          gold_id NUMBER,
          embedding VECTOR({dim}, FLOAT)
        )
        """
        mode = "native_vector"
    else:
        # Portable fallback for 12c or if Python driver lacks VECTOR bindings
        ddl = f"""
        CREATE TABLE {table} (
          id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          text CLOB,
          gold_id NUMBER,
          embedding CLOB -- JSON-encoded float array
        )
        """
        mode = "json_clob"

    cur.execute(ddl)
    conn.commit()
    return {"mode": mode, "dim": dim, "version_major": major}

def insert_embeddings(conn, table: str, texts: List[str], gold_ids: List[int], X: np.ndarray, mode: str):
    cur = conn.cursor()
    if mode == "native_vector":
        # Attempt native VECTOR binding; fall back to JSON if binding fails
        try:
            cur.setinputsizes(vec=oracledb.DB_TYPE_VECTOR)
            rows = [(t, int(g), x.tolist()) for t, g, x in zip(texts, gold_ids, X)]
            cur.executemany(f"INSERT INTO {table} (text, gold_id, embedding) VALUES (:1, :2, :vec)", rows)
        except Exception:
            # Fallback: store JSON in the same table (embedding column is VECTOR; so fallback not possible).
            # If native vector insert fails, re-create table as JSON and retry.
            conn.rollback()
            create_table(conn, table, X.shape[1], prefer_native=False)
            cur = conn.cursor()
            rows = [(t, int(g), json.dumps([float(v) for v in x.tolist()])) for t, g, x in zip(texts, gold_ids, X)]
            cur.executemany(f"INSERT INTO {table} (text, gold_id, embedding) VALUES (:1, :2, :3)", rows)
    else:
        rows = [(t, int(g), json.dumps([float(v) for v in x.tolist()])) for t, g, x in zip(texts, gold_ids, X)]
        cur.executemany(f"INSERT INTO {table} (text, gold_id, embedding) VALUES (:1, :2, :3)", rows)
    conn.commit()

def search(conn, table: str, query_vec: np.ndarray, k: int) -> List[Dict[str, Any]]:
    """Return list of {id, gold_id, text, score} sorted by similarity (higher is better)."""
    cur = conn.cursor()
    # Detect storage mode by column type
    cur.execute(f"SELECT data_type FROM all_tab_columns WHERE table_name = :t AND column_name='EMBEDDING'", [table.upper()])
    row = cur.fetchone()
    col_type = row[0] if row else "CLOB"
    # Native 23ai path
    if col_type.upper().startswith("VECTOR") and _has_db_type_vector():
        try:
            sql = f"""
            SELECT id, gold_id, text, 1 - VECTOR_DISTANCE(embedding, :vec, COSINE) AS score
            FROM {table}
            ORDER BY embedding <-> :vec
            FETCH FIRST {int(k)} ROWS ONLY
            """
            cur.setinputsizes(vec=oracledb.DB_TYPE_VECTOR)
            cur.execute(sql, vec=query_vec.tolist())
            rows = cur.fetchall()
            return [ {"id": r[0], "gold_id": int(r[1]), "text": r[2], "score": float(r[3])} for r in rows ]
        except Exception:
            # Fall through to Python scoring
            pass

    # JSON fallback (12c or driver without VECTOR)
    cur.execute(f"SELECT id, gold_id, text, embedding FROM {table}")
    items = cur.fetchall()
    q = query_vec.astype("float32")
    qn = np.linalg.norm(q) + 1e-8
    res = []
    for iid, gid, txt, emb_json in items:
        try:
            v = np.array(json.loads(emb_json), dtype="float32")
            score = float(np.dot(v, q) / ((np.linalg.norm(v) + 1e-8) * qn))
            res.append({"id": iid, "gold_id": int(gid), "text": txt, "score": score})
        except Exception:
            continue
    res.sort(key=lambda x: -x["score"])  # cosine similarity desc
    return res[:k]
