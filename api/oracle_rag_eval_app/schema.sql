-- Core storage for the Oracle RAG Trainer & Evaluator
-- Compatible with 12c–23c
-- Run as the application user (owner)

drop table rag_eval_case;
drop table rag_eval_run;
drop table RAG_PROMPT_TEMPLATE;
drop table rag_sql;
drop table RAG_EMBEDDING;
drop table RAG_QUESTION_SYNONYM;
drop table RAG_QUESTION ;
drop table RAG_DDL;








CREATE TABLE RAG_DDL (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  owner        VARCHAR2(128),
  object_type  VARCHAR2(30),
  object_name  VARCHAR2(128),
  ddl          CLOB,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_ddl_pk PRIMARY KEY (id)
);


CREATE TABLE RAG_QUESTION (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  question     CLOB NOT NULL,
  table_name   VARCHAR2(128),
  column_list  CLOB,
  ground_sql   CLOB, -- optional: ground truth SQL if known
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_q_pk PRIMARY KEY (id)
);


CREATE TABLE RAG_QUESTION_SYNONYM (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  question_id  NUMBER NOT NULL,
  synonym_text CLOB NOT NULL,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_qs_pk PRIMARY KEY (id),
  CONSTRAINT rag_qs_q_fk FOREIGN KEY (question_id) REFERENCES RAG_QUESTION(id) ON DELETE CASCADE
);

-- Store embeddings as BLOB (float32) with dimension for 12c–23c portability


CREATE TABLE RAG_EMBEDDING (
  id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  question_id   NUMBER,         -- nullable; can be null if this embedding is for a synonym
  synonym_id    NUMBER,
  provider      VARCHAR2(40),
  model         VARCHAR2(200),
  dim           NUMBER NOT NULL,
  vector_blob   BLOB NOT NULL,  -- serialized numpy float32
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_emb_pk PRIMARY KEY (id),
  CONSTRAINT rag_emb_q_fk FOREIGN KEY (question_id) REFERENCES RAG_QUESTION(id) ON DELETE CASCADE,
  CONSTRAINT rag_emb_qs_fk FOREIGN KEY (synonym_id) REFERENCES RAG_QUESTION_SYNONYM(id) ON DELETE CASCADE
);



CREATE TABLE RAG_SQL (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  question_id  NUMBER NOT NULL,
  sql_text     CLOB NOT NULL,
  notes        CLOB,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_sql_pk PRIMARY KEY (id),
  CONSTRAINT rag_sql_q_fk FOREIGN KEY (question_id) REFERENCES RAG_QUESTION(id) ON DELETE CASCADE
);


CREATE TABLE RAG_PROMPT_TEMPLATE (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  name         VARCHAR2(128) UNIQUE,
  template     CLOB NOT NULL,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  updated_at   TIMESTAMP,
  CONSTRAINT rag_prompt_template_pk PRIMARY KEY (id)
);


CREATE TABLE RAG_EVAL_RUN (
  id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  name         VARCHAR2(200),
  prompt_id    NUMBER,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  notes        CLOB,
  CONSTRAINT rag_eval_run_pk PRIMARY KEY (id),
  CONSTRAINT rag_eval_run_prompt_fk FOREIGN KEY (prompt_id) REFERENCES RAG_PROMPT_TEMPLATE(id)
);



CREATE TABLE RAG_EVAL_CASE (
  id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
  eval_run_id    NUMBER NOT NULL,
  question_id    NUMBER NOT NULL,
  synonym_id     NUMBER,
  ground_sql_id  NUMBER,
  llm_sql        CLOB,
  ground_ok      CHAR(1),
  llm_ok         CHAR(1),
  same_shape     CHAR(1),
  same_sample    CHAR(1),
  error_text     CLOB,
  exec_ms_ground NUMBER,
  exec_ms_llm    NUMBER,
  created_at     TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT rag_eval_case_pk PRIMARY KEY (id),
  CONSTRAINT rag_eval_case_run_fk FOREIGN KEY (eval_run_id) REFERENCES RAG_EVAL_RUN(id) ON DELETE CASCADE,
  CONSTRAINT rag_eval_case_q_fk FOREIGN KEY (question_id) REFERENCES RAG_QUESTION(id) ON DELETE CASCADE,
  CONSTRAINT rag_eval_case_g_fk FOREIGN KEY (ground_sql_id) REFERENCES RAG_SQL(id) ON DELETE SET NULL
);

-- Minimal default prompt
INSERT INTO RAG_PROMPT_TEMPLATE(name, template)
VALUES (
  'default_sql_gen',
  'You are an assistant that writes Oracle SQL only. Given a natural language question and a schema DDL excerpt, write a single valid SQL query. Use ANSI joins, qualify all identifiers when ambiguous, and never include comments or explanations.'
);

commit;