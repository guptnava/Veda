--------------------------------------------------------------------------------
-- Helper tables to hold proposals (created if absent)
--------------------------------------------------------------------------------
CREATE TABLE star_proposal_runs (
  run_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  run_ts        TIMESTAMP DEFAULT SYSTIMESTAMP,
  table_owner   VARCHAR2(128),
  table_name    VARCHAR2(128),
  row_count     NUMBER,
  sample_pct    NUMBER,
  notes         VARCHAR2(4000)
);

CREATE TABLE star_proposal_columns (
  run_id        NUMBER REFERENCES star_proposal_runs(run_id),
  column_name   VARCHAR2(128),
  data_type     VARCHAR2(128),
  data_length   NUMBER,
  data_precision NUMBER,
  data_scale     NUMBER,
  nullable_flag  CHAR(1),
  distinct_cnt   NUMBER,
  null_cnt       NUMBER,
  reuse_ratio    NUMBER,              -- rows / distinct
  role_guess     VARCHAR2(30),        -- MEASURE/DATE/FLAG/ID/CODE/TEXT
  CONSTRAINT pk_sp_cols PRIMARY KEY (run_id, column_name)
);

CREATE TABLE star_proposal_dimensions (
  run_id        NUMBER REFERENCES star_proposal_runs(run_id),
  dim_name      VARCHAR2(128),
  key_column    VARCHAR2(128),
  distinct_cnt  NUMBER,
  reuse_ratio   NUMBER,
  fd_attr_count NUMBER,               -- how many attrs appear functionally dependent
  fd_checked    NUMBER,               -- how many attrs checked
  score         NUMBER,               -- heuristic 0..100
  CONSTRAINT pk_sp_dims PRIMARY KEY (run_id, dim_name)
);

CREATE TABLE star_proposal_dim_attrs (
  run_id        NUMBER REFERENCES star_proposal_runs(run_id),
  dim_name      VARCHAR2(128),
  attribute_col VARCHAR2(128),
  fd_holds      CHAR(1),              -- 'Y' if FD holds on sample
  violations    NUMBER,               -- groups with cnt>1
  CONSTRAINT pk_sp_dimattrs PRIMARY KEY (run_id, dim_name, attribute_col)
);

CREATE TABLE star_proposal_fact_cols (
  run_id        NUMBER REFERENCES star_proposal_runs(run_id),
  category      VARCHAR2(20),         -- MEASURE | DATE_FK | FACT_FK | JUNK | DEGENERATE | OTHER
  column_name   VARCHAR2(128),
  notes         VARCHAR2(4000)
);
/

CREATE TABLE star_proposal_ddls (
        run_id      NUMBER,
        seq_no      NUMBER,
        object_type VARCHAR2(30),
        object_name VARCHAR2(128),
        ddl         CLOB,
        CONSTRAINT pk_sp_ddls PRIMARY KEY (run_id, seq_no)
      );
/


--------------------------------------------------------------------------------
-- Package: PROPOSE_STAR
--------------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE propose_star AS
  PROCEDURE analyze(
    p_table_name          IN VARCHAR2,
    p_table_owner         IN VARCHAR2 DEFAULT USER,
    p_min_reuse_ratio     IN NUMBER   DEFAULT 3,
    p_max_key_candidates  IN NUMBER   DEFAULT 12,
    p_max_attrs_per_dim   IN NUMBER   DEFAULT 40,
    p_sample_pct          IN NUMBER   DEFAULT NULL
  );

  -- Emit DDLs from a proposal (writes to STAR_PROPOSAL_DDLS, prints a summary)
  PROCEDURE emit_ddls(
    p_run_id             IN NUMBER   DEFAULT NULL,       -- NULL = latest run
    p_fact_name          IN VARCHAR2 DEFAULT NULL,       -- NULL = FACT_<source table>
    p_min_dim_score      IN NUMBER   DEFAULT 50,
    p_partition_date_col IN VARCHAR2 DEFAULT NULL,       -- NULL = best DATE (COB% if present)
    p_tablespace         IN VARCHAR2 DEFAULT NULL        -- optional TABLESPACE name for tables/indexes
  );

  -- (Optional) Execute the emitted DDLs (best for dev)
  PROCEDURE run_emitted_ddls(
    p_run_id IN NUMBER,
    p_like_object_type IN VARCHAR2 DEFAULT NULL, -- e.g. 'TABLE' or 'INDEX'
    p_like_object_name IN VARCHAR2 DEFAULT NULL  -- wildcard filter
  );
END propose_star;
/

CREATE OR REPLACE PACKAGE BODY propose_star AS
  ------------------------------------------------------------------------------
  -- Helpers (same + a few new ones)
  ------------------------------------------------------------------------------
  FUNCTION like_any(p_str IN VARCHAR2, p_pat IN VARCHAR2) RETURN BOOLEAN IS
    v_str VARCHAR2(4000) := UPPER(p_str);
  BEGIN
    FOR tok IN (
      SELECT TRIM(REGEXP_SUBSTR(p_pat, '[^,]+', 1, LEVEL)) AS pat
      FROM   dual
      CONNECT BY LEVEL <= REGEXP_COUNT(p_pat, ',') + 1
    ) LOOP
      IF v_str LIKE UPPER(tok.pat) ESCAPE '\' THEN RETURN TRUE; END IF;
    END LOOP;
    RETURN FALSE;
  END like_any;

  FUNCTION role_guess(
    p_col_name   VARCHAR2,
    p_data_type  VARCHAR2,
    p_prec       NUMBER,
    p_scale      NUMBER
  ) RETURN VARCHAR2 IS
    n VARCHAR2(128) := UPPER(p_col_name);
  BEGIN
    IF p_data_type = 'DATE' THEN RETURN 'DATE'; END IF;
    IF like_any(n, '%_ID,%ID,%_CODE,%CODE') THEN RETURN 'ID'; END IF;
    IF p_data_type = 'NUMBER' THEN
      IF p_scale > 0
         OR NVL(p_prec,0) >= 12
         OR like_any(n, '%AMOUNT%,%QTY%,%QUANTITY%,%PRICE%,%VALUE%,%RATE%,%VOL%,%PCT%,%PERCENT%,%SIZE%,%STRIKE%,%TENOR%')
      THEN RETURN 'MEASURE'; END IF;
    END IF;
    IF like_any(n, '%FLAG%,%IND%,%INDICATOR%,%TYPE%,%CLASS%,%CATEGORY%') THEN RETURN 'FLAG'; END IF;
    RETURN 'TEXT';
  END role_guess;

  -- Type expression for a column from ALL_TAB_COLUMNS metadata captured earlier
  FUNCTION type_expr(p_dt VARCHAR2, p_len NUMBER, p_prec NUMBER, p_scale NUMBER) RETURN VARCHAR2 IS
  BEGIN
    IF p_dt = 'DATE' THEN RETURN 'DATE';
    ELSIF p_dt = 'NUMBER' THEN
      IF p_prec IS NOT NULL THEN
        IF p_scale IS NOT NULL THEN RETURN 'NUMBER('||p_prec||','||p_scale||')';
        ELSE RETURN 'NUMBER('||p_prec||')'; END IF;
      ELSE
        RETURN 'NUMBER';
      END IF;
    ELSIF p_dt IN ('VARCHAR2','CHAR') THEN
      RETURN p_dt||'('||NVL(p_len,1)||')';
    ELSE
      RETURN p_dt; -- fallback
    END IF;
  END;

  -- Build legal identifier (upper, underscores only) and trim to 30 chars
  FUNCTION ident30(p_name IN VARCHAR2) RETURN VARCHAR2 IS
    v VARCHAR2(200) := REGEXP_REPLACE(UPPER(p_name),'[^A-Z0-9_]+','_');
  BEGIN
    RETURN SUBSTR(v,1,30);
  END;

  ------------------------------------------------------------------------------
  -- ANALYZE (unchanged core)
  ------------------------------------------------------------------------------
  -- REPLACE ONLY THIS PROCEDURE in the package body
PROCEDURE analyze(
  p_table_name          IN VARCHAR2,
  p_table_owner         IN VARCHAR2,
  p_min_reuse_ratio     IN NUMBER,
  p_max_key_candidates  IN NUMBER,
  p_max_attrs_per_dim   IN NUMBER,
  p_sample_pct          IN NUMBER
) IS
  l_run_id       NUMBER;
  l_row_cnt      NUMBER;
  l_sample_sql   VARCHAR2(50) := CASE WHEN p_sample_pct IS NOT NULL
                                      THEN ' SAMPLE('||TO_CHAR(p_sample_pct)||') '
                                      ELSE ' ' END;
  l_src_owner    VARCHAR2(128) := UPPER(p_table_owner);
  l_src_table    VARCHAR2(128) := UPPER(p_table_name);
BEGIN
  --------------------------------------------------------------------------
  -- 1) Table size
  --------------------------------------------------------------------------
  EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM "'||l_src_owner||'"."'||l_src_table||'"'
    INTO l_row_cnt;

  INSERT INTO star_proposal_runs(table_owner, table_name, row_count, sample_pct, notes)
  VALUES (l_src_owner, l_src_table, l_row_cnt, p_sample_pct,
          'min_reuse='||p_min_reuse_ratio||', max_keys='||p_max_key_candidates||', max_attrs='||p_max_attrs_per_dim);
  SELECT MAX(run_id) INTO l_run_id FROM star_proposal_runs;

  DBMS_OUTPUT.PUT_LINE('Run '||l_run_id||' on '||l_src_owner||'.'||l_src_table||' rows='||l_row_cnt);

  --------------------------------------------------------------------------
  -- 2) Profile columns
  --------------------------------------------------------------------------
  FOR c IN (
    SELECT column_name, data_type, data_length, data_precision, data_scale, nullable
    FROM   all_tab_columns
    WHERE  owner = l_src_owner
    AND    table_name = l_src_table
    ORDER  BY column_id
  ) LOOP
    DECLARE
      l_dist NUMBER; l_nulls NUMBER; l_role VARCHAR2(30);
      vsql1  VARCHAR2(32767);
      vsql2  VARCHAR2(32767);
    BEGIN
      vsql1 := 'SELECT COUNT(DISTINCT "'||c.column_name||'") FROM "'||l_src_owner||'"."'||l_src_table||'"'||
               l_sample_sql||' WHERE "'||c.column_name||'" IS NOT NULL';
      vsql2 := 'SELECT COUNT(*) - COUNT("'||c.column_name||'") FROM "'||l_src_owner||'"."'||l_src_table||'"'||l_sample_sql;

      EXECUTE IMMEDIATE vsql1 INTO l_dist;
      EXECUTE IMMEDIATE vsql2 INTO l_nulls;

      l_role := role_guess(c.column_name, c.data_type, c.data_precision, c.data_scale);

      INSERT INTO star_proposal_columns
      (run_id, column_name, data_type, data_length, data_precision, data_scale, nullable_flag,
       distinct_cnt, null_cnt, reuse_ratio, role_guess)
      VALUES
      (l_run_id, c.column_name, c.data_type, c.data_length, c.data_precision, c.data_scale, c.nullable,
       l_dist, l_nulls, CASE WHEN l_dist > 0 THEN l_row_cnt / l_dist ELSE NULL END, l_role);
    END;
  END LOOP;
  COMMIT;

  --------------------------------------------------------------------------
  -- 3) Candidate dimension keys
  --------------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('Identifying candidate dimension keys...');
  FOR k IN (
    SELECT *
    FROM (
      SELECT column_name, distinct_cnt, reuse_ratio
      FROM   star_proposal_columns
      WHERE  run_id = l_run_id
        AND  role_guess IN ('ID','TEXT')
        AND  reuse_ratio >= p_min_reuse_ratio
        AND  distinct_cnt > 1
      ORDER  BY reuse_ratio DESC, distinct_cnt ASC
    )
    WHERE ROWNUM <= p_max_key_candidates
  ) LOOP
    DECLARE
      l_fd_ok   NUMBER := 0;
      l_fd_chk  NUMBER := 0;
      l_dim_name VARCHAR2(128) := 'DIM_'||SUBSTR(k.column_name,1,100);
    BEGIN
      DBMS_OUTPUT.PUT_LINE('  Checking key '||k.column_name||' (reuse='||TO_CHAR(k.reuse_ratio,'FM9990.00')||')');

      FOR a IN (
        SELECT column_name, role_guess
        FROM   star_proposal_columns
        WHERE  run_id = l_run_id
          AND  column_name <> k.column_name
          AND  role_guess NOT IN ('MEASURE')
        ORDER  BY CASE role_guess WHEN 'FLAG' THEN 0 WHEN 'TEXT' THEN 1 WHEN 'ID' THEN 2 ELSE 3 END, column_name
      ) LOOP
        EXIT WHEN l_fd_chk >= p_max_attrs_per_dim;

        DECLARE
          vsql  VARCHAR2(32767);
          vviol NUMBER;
        BEGIN
          -- ✅ Use owner/table variables; include SAMPLE if provided
          vsql := 'SELECT COUNT(1) FROM ( '||
                  ' SELECT "'||k.column_name||'", COUNT(DISTINCT "'||a.column_name||'") cnt '||
                  ' FROM "'||l_src_owner||'"."'||l_src_table||'"'||l_sample_sql||
                  ' GROUP BY "'||k.column_name||'") WHERE cnt > 1';
          EXECUTE IMMEDIATE vsql INTO vviol;

          l_fd_chk := l_fd_chk + 1;

          INSERT INTO star_proposal_dim_attrs(run_id, dim_name, attribute_col, fd_holds, violations)
          VALUES (l_run_id, l_dim_name, a.column_name, CASE WHEN vviol = 0 THEN 'Y' ELSE 'N' END, vviol);

          IF vviol = 0 THEN l_fd_ok := l_fd_ok + 1; END IF;
        END;
      END LOOP;

      -- Score = 70% FD coverage + 30% reuse strength
      DECLARE
        l_score NUMBER := NVL(
                         (CASE WHEN l_fd_chk > 0 THEN (100.0 * l_fd_ok / l_fd_chk) ELSE 0 END) * 0.7
                         + LEAST(100, 10 * LN(1 + NVL(k.reuse_ratio,0))) * 0.3,
                         0);
      BEGIN
        INSERT INTO star_proposal_dimensions
          (run_id, dim_name, key_column, distinct_cnt, reuse_ratio, fd_attr_count, fd_checked, score)
        VALUES
          (l_run_id, l_dim_name, k.column_name, k.distinct_cnt, k.reuse_ratio, l_fd_ok, l_fd_chk, ROUND(l_score,1));
      END;
    END;
  END LOOP;
  COMMIT;

  --------------------------------------------------------------------------
  -- 4) Propose fact columns
  --------------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('Proposing fact columns...');

  INSERT INTO star_proposal_fact_cols(run_id, category, column_name, notes)
  SELECT l_run_id, 'MEASURE', column_name, 'Numeric measure by name/type'
  FROM   star_proposal_columns
  WHERE  run_id = l_run_id AND role_guess = 'MEASURE';

  INSERT INTO star_proposal_fact_cols(run_id, category, column_name, notes)
  SELECT l_run_id, 'DATE_FK', column_name, 'DATE → role-played dim_date'
  FROM   star_proposal_columns
  WHERE  run_id = l_run_id AND role_guess = 'DATE';

  INSERT INTO star_proposal_fact_cols(run_id, category, column_name, notes)
  SELECT l_run_id, 'JUNK', column_name, 'Low-cardinality flag/code (consider junk dim)'
  FROM   star_proposal_columns
  WHERE  run_id = l_run_id
    AND  role_guess IN ('FLAG','TEXT')
    AND  NVL(distinct_cnt,0) BETWEEN 2 AND 50;

  INSERT INTO star_proposal_fact_cols(run_id, category, column_name, notes)
  SELECT l_run_id, 'DEGENERATE', column_name, 'Near-unique identifier (keep on fact)'
  FROM   star_proposal_columns
  WHERE  run_id = l_run_id
    AND  role_guess IN ('ID','TEXT')
    AND  ( reuse_ratio BETWEEN 0.9 AND 1.2
           OR distinct_cnt > 0.5 * l_row_cnt );

  INSERT INTO star_proposal_fact_cols(run_id, category, column_name, notes)
  SELECT l_run_id, 'FACT_FK', d.key_column, 'FK to '||d.dim_name||' (score='||d.score||')'
  FROM   star_proposal_dimensions d
  WHERE  d.run_id = l_run_id AND d.score >= 50;

  COMMIT;

  DBMS_OUTPUT.PUT_LINE('Run '||l_run_id||' complete.');
END analyze;


  ------------------------------------------------------------------------------
  -- Emit DDLs based on latest proposal
  ------------------------------------------------------------------------------
  PROCEDURE emit_ddls(
    p_run_id             IN NUMBER,
    p_fact_name          IN VARCHAR2,
    p_min_dim_score      IN NUMBER,
    p_partition_date_col IN VARCHAR2,
    p_tablespace         IN VARCHAR2
  ) IS
    l_run_id     NUMBER := p_run_id;
    l_src_owner  VARCHAR2(128);
    l_src_table  VARCHAR2(128);
    l_seq        NUMBER := 0;

    PROCEDURE put(p_type VARCHAR2, p_name VARCHAR2, p_sql CLOB) IS
    BEGIN
      l_seq := l_seq + 1;
      INSERT INTO star_proposal_ddls(run_id, seq_no, object_type, object_name, ddl)
      VALUES (l_run_id, l_seq, p_type, p_name, p_sql);
    END;

    FUNCTION tblspace_clause RETURN VARCHAR2 IS
    BEGIN
      RETURN CASE WHEN p_tablespace IS NOT NULL THEN ' TABLESPACE '||p_tablespace ELSE NULL END;
    END;

  BEGIN
    -- Determine run
    IF l_run_id IS NULL THEN
      SELECT MAX(run_id) INTO l_run_id FROM star_proposal_runs;
    END IF;
    IF l_run_id IS NULL THEN
      RAISE_APPLICATION_ERROR(-20001, 'No proposal run found. Run PROPOSE_STAR.ANALYZE first.');
    END IF;

    SELECT table_owner, table_name INTO l_src_owner, l_src_table
    FROM star_proposal_runs WHERE run_id = l_run_id;

    -- Choose fact name
    DECLARE
      l_fact_name VARCHAR2(128) := NVL(p_fact_name, 'FACT_'||ident30(l_src_table));
      l_part_col  VARCHAR2(128);
      l_cols      CLOB;
      l_sql       CLOB;
      l_ts        VARCHAR2(200) := tblspace_clause;
    BEGIN
      -- Ensure DIM_DATE DDL first (idempotent to run, but we just emit)
      put('TABLE','DIM_DATE', 'CREATE TABLE DIM_DATE ('||CHR(10)||
          '  DATE_KEY DATE PRIMARY KEY,'||CHR(10)||
          '  FULL_DATE DATE NOT NULL,'||CHR(10)||
          '  DAY_OF_WEEK NUMBER(1) NOT NULL,'||CHR(10)||
          '  DAY_NAME VARCHAR2(9) NOT NULL,'||CHR(10)||
          '  DAY_OF_MONTH NUMBER(2) NOT NULL,'||CHR(10)||
          '  WEEK_OF_YEAR NUMBER(2) NOT NULL,'||CHR(10)||
          '  MONTH_NUMBER NUMBER(2) NOT NULL,'||CHR(10)||
          '  MONTH_NAME VARCHAR2(9) NOT NULL,'||CHR(10)||
          '  QUARTER_NUMBER NUMBER(1) NOT NULL,'||CHR(10)||
          '  YEAR_NUMBER NUMBER(4) NOT NULL,'||CHR(10)||
          '  IS_MONTH_END CHAR(1) CHECK (IS_MONTH_END IN (''Y'',''N'')),'||CHR(10)||
          '  IS_QUARTER_END CHAR(1) CHECK (IS_QUARTER_END IN (''Y'',''N'')),'||CHR(10)||
          '  IS_YEAR_END CHAR(1) CHECK (IS_YEAR_END IN (''Y'',''N''))'||CHR(10)||
          ')'||l_ts);

      -- For each high-scoring dimension candidate, create a dimension table
      FOR d IN (
        SELECT dim_name,
               key_column,
               score
        FROM   star_proposal_dimensions
        WHERE  run_id = l_run_id
        AND    score >= p_min_dim_score
        ORDER  BY score DESC
      ) LOOP
        -- Column type of the natural key
        DECLARE
          nk_type VARCHAR2(200);
          nk_len  NUMBER; nk_prec NUMBER; nk_scale NUMBER; nk_dt VARCHAR2(30);
          short   VARCHAR2(128);
          sk_col  VARCHAR2(128);
          col_list CLOB;
          firstcol BOOLEAN := TRUE;
          ts VARCHAR2(200) := tblspace_clause;
          uidx_name VARCHAR2(128);
        BEGIN
          SELECT data_type, data_length, data_precision, data_scale
          INTO   nk_dt, nk_len, nk_prec, nk_scale
          FROM   star_proposal_columns
          WHERE  run_id = l_run_id AND column_name = d.key_column;

          nk_type := type_expr(nk_dt, nk_len, nk_prec, nk_scale);
          short   := REGEXP_REPLACE(d.dim_name,'^DIM_','');
          short   := ident30(short);
          sk_col  := ident30(short||'_KEY');
          uidx_name := ident30('U_'||d.dim_name||'_NK');

          -- Build column list (surrogate key + NK + attributes where FD holds)
          col_list := '  '||sk_col||' NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY'||CHR(10)||
                      ', '||d.key_column||' '||nk_type||CHR(10);

          FOR a IN (
            SELECT a.attribute_col, c.data_type, c.data_length, c.data_precision, c.data_scale
            FROM   star_proposal_dim_attrs a
            JOIN   star_proposal_columns c
              ON   c.run_id=a.run_id AND c.column_name=a.attribute_col
            WHERE  a.run_id = l_run_id
              AND  a.dim_name = d.dim_name
              AND  a.fd_holds = 'Y'
              AND  a.attribute_col <> d.key_column
              AND  NVL(c.role_guess,'TEXT') <> 'MEASURE'
          ) LOOP
            col_list := col_list||', '||a.attribute_col||' '||type_expr(a.data_type, a.data_length, a.data_precision, a.data_scale)||CHR(10);
          END LOOP;

          -- Emit CREATE TABLE + unique index on NK
          put('TABLE', d.dim_name, 'CREATE TABLE '||d.dim_name||' ('||CHR(10)||col_list||')'||ts);
          put('INDEX', uidx_name, 'CREATE UNIQUE INDEX '||uidx_name||' ON '||d.dim_name||'('||d.key_column||')'||ts);
        END;
      END LOOP;

      ----------------------------------------------------------------------------
      -- Build fact table DDL
      ----------------------------------------------------------------------------
      l_cols := NULL;

      -- 1) DATE columns (role-played to DIM_DATE)
      FOR r IN (
        SELECT c.column_name, c.data_type, c.data_length, c.data_precision, c.data_scale
        FROM   star_proposal_fact_cols f
        JOIN   star_proposal_columns c ON c.run_id=f.run_id AND c.column_name=f.column_name
        WHERE  f.run_id = l_run_id AND f.category='DATE_FK'
        ORDER  BY c.column_name
      ) LOOP
        IF l_cols IS NULL THEN
          l_cols := '  '||r.column_name||' DATE';
        ELSE
          l_cols := l_cols||','||CHR(10)||'  '||r.column_name||' DATE';
        END IF;
      END LOOP;

      -- 2) FK columns to dimensions (one NUMBER surrogate per generated dim)
      FOR d IN (
        SELECT dim_name, key_column
        FROM   star_proposal_dimensions
        WHERE  run_id = l_run_id AND score >= p_min_dim_score
        ORDER  BY score DESC
      ) LOOP
        DECLARE
          short VARCHAR2(128) := ident30(REGEXP_REPLACE(d.dim_name,'^DIM_',''));
          fkcol VARCHAR2(128) := ident30(short||'_KEY');
        BEGIN
          l_cols := NVL(l_cols,'')||CASE WHEN l_cols IS NULL THEN '  ' ELSE ','||CHR(10)||'  ' END||fkcol||' NUMBER';
        END;
      END LOOP;

      -- 3) Measures
      FOR m IN (
        SELECT c.column_name, c.data_type, c.data_length, c.data_precision, c.data_scale
        FROM   star_proposal_fact_cols f
        JOIN   star_proposal_columns c ON c.run_id=f.run_id AND c.column_name=f.column_name
        WHERE  f.run_id = l_run_id AND f.category='MEASURE'
        ORDER  BY c.column_name
      ) LOOP
        l_cols := NVL(l_cols,'')||CASE WHEN l_cols IS NULL THEN '  ' ELSE ','||CHR(10)||'  ' END||
                  m.column_name||' '||type_expr(m.data_type, m.data_length, m.data_precision, m.data_scale);
      END LOOP;

      -- 4) Junk + Degenerate kept on fact
      FOR j IN (
        SELECT c.column_name, c.data_type, c.data_length, c.data_precision, c.data_scale
        FROM   star_proposal_fact_cols f
        JOIN   star_proposal_columns c ON c.run_id=f.run_id AND c.column_name=f.column_name
        WHERE  f.run_id = l_run_id AND f.category IN ('JUNK','DEGENERATE')
        ORDER  BY c.column_name
      ) LOOP
        l_cols := NVL(l_cols,'')||CASE WHEN l_cols IS NULL THEN '  ' ELSE ','||CHR(10)||'  ' END||
                  j.column_name||' '||type_expr(j.data_type, j.data_length, j.data_precision, j.data_scale);
      END LOOP;

      -- Choose partition date column:
      SELECT column_name
      INTO   l_part_col
      FROM (
        -- prefer something like COB%
        SELECT column_name, 1 pr
        FROM   star_proposal_fact_cols
        WHERE  run_id = l_run_id AND category='DATE_FK' AND UPPER(column_name) LIKE 'COB%'
        UNION ALL
        SELECT column_name, 2
        FROM   star_proposal_fact_cols
        WHERE  run_id = l_run_id AND category='DATE_FK'
      )
      WHERE ROWNUM=1;

      -- Create fact table DDL (partitioned monthly on chosen date)
      l_sql := 'CREATE TABLE '||NVL(p_fact_name, l_fact_name)||' ('||CHR(10)||
               '  FACT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,'||CHR(10)||
               NVL(l_cols,'  -- no columns proposed')||CHR(10)||
               ')'||
               NVL(tblspace_clause,'')||CHR(10)||
               'PARTITION BY RANGE ('||l_part_col||')'||CHR(10)||
               '  INTERVAL (NUMTOYMINTERVAL(1,''MONTH''))'||CHR(10)||
               '  ( PARTITION P_MIN VALUES LESS THAN (DATE ''2000-01-01'') )';

      put('TABLE', NVL(p_fact_name, l_fact_name), l_sql);

      -- FKs to DIM_DATE for each DATE_FK column
      FOR r IN (
        SELECT column_name
        FROM   star_proposal_fact_cols
        WHERE  run_id = l_run_id AND category='DATE_FK'
      ) LOOP
        put('CONSTRAINT',
            ident30('FK_'||NVL(p_fact_name, l_fact_name)||'_'||r.column_name),
            'ALTER TABLE '||NVL(p_fact_name, l_fact_name)||
            ' ADD CONSTRAINT '||ident30('FK_'||NVL(p_fact_name, l_fact_name)||'_'||r.column_name)||
            ' FOREIGN KEY ('||r.column_name||') REFERENCES DIM_DATE(DATE_KEY)');
      END LOOP;

      -- FKs to generated dimensions
      FOR d IN (
        SELECT dim_name, key_column
        FROM   star_proposal_dimensions
        WHERE  run_id = l_run_id AND score >= p_min_dim_score
        ORDER  BY score DESC
      ) LOOP
        DECLARE
          short   VARCHAR2(128) := ident30(REGEXP_REPLACE(d.dim_name,'^DIM_',''));
          fkcol   VARCHAR2(128) := ident30(short||'_KEY');
          fkname  VARCHAR2(128) := ident30('FK_'||NVL(p_fact_name, l_fact_name)||'_'||short);
        BEGIN
          put('CONSTRAINT', fkname,
              'ALTER TABLE '||NVL(p_fact_name, l_fact_name)||
              ' ADD CONSTRAINT '||fkname||
              ' FOREIGN KEY ('||fkcol||') REFERENCES '||d.dim_name||'('||fkcol||')');
        END;
      END LOOP;

      -- Bitmap indexes on date columns
      FOR r IN (
        SELECT column_name
        FROM   star_proposal_fact_cols
        WHERE  run_id = l_run_id AND category='DATE_FK'
      ) LOOP
        put('INDEX',
            ident30('BIX_'||NVL(p_fact_name, l_fact_name)||'_'||r.column_name),
            'CREATE BITMAP INDEX '||ident30('BIX_'||NVL(p_fact_name, l_fact_name)||'_'||r.column_name)||
            ' ON '||NVL(p_fact_name, l_fact_name)||'('||r.column_name||')'||tblspace_clause);
      END LOOP;

      -- Bitmap indexes on FK columns to dims
      FOR d IN (
        SELECT dim_name
        FROM   star_proposal_dimensions
        WHERE  run_id = l_run_id AND score >= p_min_dim_score
      ) LOOP
        DECLARE
          short   VARCHAR2(128) := ident30(REGEXP_REPLACE(d.dim_name,'^DIM_',''));
          fkcol   VARCHAR2(128) := ident30(short||'_KEY');
          ixname  VARCHAR2(128) := ident30('BIX_'||NVL(p_fact_name, l_fact_name)||'_'||fkcol);
        BEGIN
          put('INDEX', ixname,
              'CREATE BITMAP INDEX '||ixname||
              ' ON '||NVL(p_fact_name, l_fact_name)||'('||fkcol||')'||tblspace_clause);
        END;
      END LOOP;

      -- Bitmap indexes on junk columns (low-card flags/codes)
      FOR j IN (
        SELECT column_name
        FROM   star_proposal_fact_cols
        WHERE  run_id = l_run_id AND category='JUNK'
      ) LOOP
        put('INDEX',
            ident30('BIX_'||NVL(p_fact_name, l_fact_name)||'_'||j.column_name),
            'CREATE BITMAP INDEX '||ident30('BIX_'||NVL(p_fact_name, l_fact_name)||'_'||j.column_name)||
            ' ON '||NVL(p_fact_name, l_fact_name)||'('||j.column_name||')'||tblspace_clause);
      END LOOP;

      COMMIT;

      DBMS_OUTPUT.PUT_LINE('DDL emitted for run '||l_run_id||' into STAR_PROPOSAL_DDLS (rows='||l_seq||').');
      DBMS_OUTPUT.PUT_LINE('Fact: '||NVL(p_fact_name, l_fact_name)||'  partitioned by '||l_part_col||'.');
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002,'No DATE column found to partition by; run ANALYZE with a table that has DATE columns, or pass P_PARTITION_DATE_COL.');
    END;
  END emit_ddls;

  ------------------------------------------------------------------------------
  -- Execute emitted DDLs (optional helper for dev sandboxes)
  ------------------------------------------------------------------------------
  PROCEDURE run_emitted_ddls(
    p_run_id IN NUMBER,
    p_like_object_type IN VARCHAR2,
    p_like_object_name IN VARCHAR2
  ) IS
  BEGIN
    FOR r IN (
      SELECT seq_no, object_type, object_name, ddl
      FROM   star_proposal_ddls
      WHERE  run_id = p_run_id
      AND    (p_like_object_type IS NULL OR UPPER(object_type) LIKE UPPER(p_like_object_type))
      AND    (p_like_object_name IS NULL OR UPPER(object_name) LIKE UPPER(p_like_object_name))
      ORDER  BY seq_no
    ) LOOP
      BEGIN
        EXECUTE IMMEDIATE r.ddl;
        DBMS_OUTPUT.PUT_LINE('Executed #'||r.seq_no||' '||r.object_type||' '||r.object_name);
      EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR on #'||r.seq_no||' '||r.object_type||' '||r.object_name||': '||SQLERRM);
      END;
    END LOOP;
  END run_emitted_ddls;

END propose_star;
/


show errors;
/

-- Recompile the fixed body
SHOW ERRORS PACKAGE BODY propose_star

-- Then run (adjust params as you like)
SET SERVEROUTPUT ON SIZE UNLIMITED
BEGIN
  propose_star.analyze(
    p_table_name         => 'EOD_RISK',
    p_table_owner        => USER,
    p_min_reuse_ratio    => 3,
    p_max_key_candidates => 12,
    p_max_attrs_per_dim  => 40,
    p_sample_pct         => 10
  );
END;
/

-- 2) Emit DDLs (score ≥ 50 dims → dims + fact + bitmap indexes)
BEGIN
  propose_star.emit_ddls(
    p_run_id             => NULL,          -- latest run
    p_fact_name          => 'FACT_EOD_RISK',
    p_min_dim_score      => 50,
    p_partition_date_col => NULL,          -- will prefer COB% if found
    p_tablespace         => NULL           -- or 'USERS'
  );
END;
/


-- Dimensions (top-scoring)
SELECT * FROM star_proposal_dimensions
WHERE run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
ORDER BY score DESC;

-- Suggested fact columns
SELECT category, column_name, notes
FROM   star_proposal_fact_cols
WHERE  run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
ORDER  BY category, column_name;

-- Column profiling
SELECT * FROM star_proposal_columns
WHERE run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
ORDER BY column_name;


-- 3) Browse generated DDL text
SELECT seq_no, object_type, object_name, SUBSTR(ddl,1,120) AS ddl_preview
FROM   star_proposal_ddls
WHERE  run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
ORDER  BY seq_no;

-- 4) (Optional) Execute them in your sandbox
SET SERVEROUTPUT ON
BEGIN
  propose_star.run_emitted_ddls(
    p_run_id => (SELECT MAX(run_id) FROM star_proposal_runs)
  );
END;
/

-- Documentation: the package **profiles a wide/denormalised table** (e.g., `EOD_RISK`), then **suggests a star schema** by (a) proposing **dimension candidates** with keys and attributes, and (b) classifying **fact columns** (measures, date FKs, junk flags, degenerates). It writes everything into small metadata tables so you can review/iterate, and it prints a summary via `DBMS_OUTPUT`.

-- Here’s what happens inside, step-by-step:

-- ## What it analyzes

-- 1. **Counts rows** in your source table.

-- 2. **Profiles every column**:

--    * `DISTINCT` count, `NULL` count.
--    * **Reuse ratio** = rows / distinct (how often values repeat).
--    * A **role guess** by name/type:

--      * `DATE` → Date FK candidate
--      * `NUMBER` with measurey names/scale → Measure
--      * Names like `_ID`, `_CODE` → ID
--      * Flags/types/categories → Flag
--      * Otherwise → Text

-- 3. **Finds dimension key candidates**

--    * Picks columns with role `ID`/`TEXT` whose **reuse ratio ≥ threshold** (defaults to 3) and non-trivial cardinality.
--    * Caps how many keys to test (default 12).

-- 4. **Tests functional dependency (FD)** for each key K

--    * For many non-measure columns A (capped per key), it checks if **K → A** holds on the data (i.e., each K has **≤ 1 distinct** A).
--    * Stores the per-attribute FD outcome and counts how many attributes *appear determined* by K.

-- 5. **Scores each dimension candidate**

--    * **Score = 70% × FD coverage + 30% × reuse strength** (reuse strength uses `LN(1+reuse)`; 0–100 scale).
--    * Writes a row per candidate dimension with key, distincts, reuse, FD stats, and score.

-- 6. **Proposes fact columns**

--    * **MEASURE**: numeric measures (amount, qty, price, rate, vol, tenor, etc.).
--    * **DATE_FK**: all `DATE` columns (role-played `dim_date`).
--    * **JUNK**: low-cardinality flags/codes (2…50 distinct).
--    * **DEGENERATE**: near-unique IDs (e.g., `TRADE_ID`).
--    * **FACT_FK**: keys of **high-scoring dimensions** (score ≥ 50).

-- ## Where results go

-- * `STAR_PROPOSAL_RUNS` – one row per analysis run.
-- * `STAR_PROPOSAL_COLUMNS` – profiling/role for every column.
-- * `STAR_PROPOSAL_DIMENSIONS` – candidate dims with key, FD stats, score.
-- * `STAR_PROPOSAL_DIM_ATTRS` – which attributes K appears to determine.
-- * `STAR_PROPOSAL_FACT_COLS` – proposed fact columns by category.

-- ## What you do with it

-- * Run `propose_star.analyze('EOD_RISK', owner => …, sample_pct => 10)` to start.
-- * Review candidates:

--   ```sql
--   SELECT * FROM star_proposal_dimensions
--   WHERE run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
--   ORDER BY score DESC;

--   SELECT category, column_name, notes
--   FROM star_proposal_fact_cols
--   WHERE run_id = (SELECT MAX(run_id) FROM star_proposal_runs)
--   ORDER BY category, column_name;
--   ```
-- * Use that proposal to design your dimension tables (keys + attributes) and decide your **fact grain** and FKs.

-- ## Knobs you can tweak

-- * `p_min_reuse_ratio` – stricter/looser key candidacy.
-- * `p_max_key_candidates`, `p_max_attrs_per_dim` – cap the FD work.
-- * `p_sample_pct` – use `SAMPLE(…)` for faster runs on big tables.

-- ## What it **doesn’t** do (by design)

-- * It **doesn’t create** the star schema tables or move data (it’s a discovery tool).
-- * It **doesn’t guarantee** FDs are perfect—dirty data or sampling can show violations later.
-- * It **doesn’t** choose SCD types; you decide (Type 1 vs 2) for changing attributes.

-- If you want, I can extend it to **emit DDL** for the proposed dimensions/fact (with SCD options) based on the latest run.
